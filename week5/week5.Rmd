---
title: "Week 6 HW"
author: "Tyler Jackson"
date: "5/1/2019"
output:
  html_document:
    theme: journal
    toc: true
    toc_float: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup

## Load Libraries
```{r lib}
library(rspatial)
library(spdep)
```

## Load Data
```{r data}
pols <- sp_data("auctb.rds")
```

# Questions

```{r nb object}
#create a rook neiborhood matrix
wr <- poly2nb(pols, row.names=pols$Id, queen=FALSE)
summary(wr)
```


```{r neighbors}
wr[1:6]
```

## 1 Explain the nb output

__Explain the meaning of the first lines returned by wr[1:6]__

> This returns the neighbors for points 1 through 6. 

****

Let's do Moran's I
```{r listw}
#create a weights matrix with listw, style B is true/false binary
ww <- nb2listw(wr, style='B')

#inspect
ww
```

```{r moran}
#moran function
moran(pols$TB, ww, n=length(ww$neighbours), S0=Szero(ww))
```

```{r moran.test}
#calculate moran.test (similar to a linear regression?)
moran.test(pols$TB, ww, randomisation=FALSE)
```

```{r moran.mc}
#monte carlo baby
moran.mc(pols$TB, ww, nsim=99)
```

## 2 Interpret Moran's I

__How do you interpret these results (the significance tests)?__

> Looking at the above plots, the `moran.test` indicates that our Moran's I is significantly different than the expected Moran's I generated with an assumed normal distribution. the `moran.mc` gives a more nuanced look, indicating that we have a significant value even when 99 simulations are run. The low p-value indicates that our value is not generated by a random process, and is indeed important to analyze. 

## 3 Good nsim

__What would a good value be for `nsim`?__

> For more confidence, a value of 999 would give a maximum p-value of `r 1/1000`, thus a greater indication of significance. `nsim` could increase, but at computational cost. 

## 4 Geary's C

__Show how to use the 'geary' function to compute Geary's C__

```{r geary c}
#geary
geary(pols$TB, #the tb data
      ww, #listw matrix
      length(ww$neighbours), #n
      length(ww$neighbours)-1, #n-1
      S0=Szero(ww)) #sum of weights
```


## 5 Monte Carlo

__Write your own Monte Carlo simulation test to compute p-values for Moran's *I*, replicating the results we obtained with the function from spdep__ Show a figure similar to Figure 7.9 in OSU.

Function for getting Moran's I
```{r randmoran}
rand.moran <- function(i) {
  r <- sample(pols$TB, 
              length(pols$TB), 
              replace = FALSE) #the tb values
  m <- moran(r, 
             ww, 
             n=length(ww$neighbours), 
             S0=Szero(ww)) #get moran's I
  return(m$I)
}
```

Get Moran's I values
```{r moran values}
set.seed(2)
rm <- sapply(1:999, rand.moran) 

am <- moran(pols$TB, ww, n=length(ww$neighbours), S0=Szero(ww))
```

Plot
```{r histogram}
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)

#get a histogram for the random and observed
hist(rm, main = "Histogram of Montecarlo Simulation of Moran's I", xlab = expression("Moran's"~italic("I")), xlim = c(-0.2, 0.35))

abline(v=am$I,col= "black", lty=2)
text(0.25, 150, "Observed value (p-value 0.001)", col = "black", srt = 90, cex = 0.8) 
```

## 6 CYO Geary C

__Write your own Geary C function, by completing the function below__

`gearyC <- ((n-1)/sum(( "----")\^2)) * sum(wm * (" --- ")\^2) / (2 * sum(wm))`


```{r}
#need weights matrix
wm <- nb2mat(wr, style='B')

y <- expand.grid(pols$TB, pols$TB)
colnames(y) <- c("y1", "y2")
```

```{r}
# c equals
# n - 1 / (sum of TB values - Mean)^2^
# times
# sum of the weights matrix * (y1 - y2)^2^

gearyC <- ((length(ww$neighbours)-1)/sum((pols$TB - mean(pols$TB))^2)) * sum(wm * (y$y1 - y$y2)^2) / (2 * sum(wm))

gearyC
```
