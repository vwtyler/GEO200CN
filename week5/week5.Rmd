---
title: "Week 6 HW"
author: "Tyler Jackson"
date: "5/1/2019"
output:
  html_document:
    theme: journal
    toc: true
    toc_float: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup

## Load Libraries
```{r lib}
library(rspatial) #data
library(spdep) #moran's and geary's
```

## Load Data
```{r data}

#get our auckland data from the rds in rspatial
pols <- sp_data("auctb.rds")
```

# Questions

```{r nb object}
#create a rook neiborhood matrix
wr <- poly2nb(pols, row.names=pols$Id, queen=FALSE)

#check it out
summary(wr)
```


```{r neighbors}
#get neighbors for polygons 1 through 6
wr[1:6]
```

## 1 Explain the nb output

__Explain the meaning of the first lines returned by wr[1:6]__

> This returns the neighbors for polygons 1 through 6. 

****

Let's do Moran's I
```{r listw}
#create a weights matrix with listw, style B is true/false binary
ww <- nb2listw(wr, style='B')

#inspect
ww
```

```{r moran}
#moran function
moran(pols$TB, ww, n=length(ww$neighbours), S0=Szero(ww))
```

```{r moran.test}
#calculate moran.test (similar to a linear regression?)
moran.test(pols$TB, ww, randomisation=FALSE)
```

```{r moran.mc}
#monte carlo baby
moran.mc(pols$TB, ww, nsim=99)
```

## 2 Interpret Moran's I

__How do you interpret these results (the significance tests)?__

> Looking at the above plots, the `moran.test` indicates that our Moran's I is significantly different than the expected Moran's I generated with an assumed normal distribution. the `moran.mc` gives a more nuanced look, indicating that we have a significant value even when 99 simulations are run. The low p-value indicates that our value is not generated by a random process, and is indeed important to analyze. 

## 3 Good nsim?

__What would a good value be for `nsim`?__

> For more confidence, a value of 999 would give a maximum p-value of `r 1/1000`, thus a greater indication of significance. `nsim` could increase beyond 999, but at computational cost. 

## 4 Geary's C

__Show how to use the 'geary' function to compute Geary's C__

```{r geary c}
#geary
c <- geary(pols$TB, #the tb data
      ww, #listw matrix
      length(ww$neighbours), #n
      length(ww$neighbours)-1, #n-1
      S0=Szero(ww)) #sum of weights

#show value
c
```


## 5 Monte Carlo

__Write your own Monte Carlo simulation test to compute p-values for Moran's *I*, replicating the results we obtained with the function from spdep__ Show a figure similar to Figure 7.9 in OSU.

Function for getting Moran's I
```{r randmoran}

#` this takes the TB values and shuffles them using `sample`
#` then it calculates and moran's i statistic and returns just the I value
#` could make this more flexible, but for now it is specific to our data
#` the i in function() makes it so sapply works (later)

rand.moran <- function(i) {
  r <- sample(pols$TB, length(pols$TB), replace = FALSE) #shuffle TB vals
  m <- moran(r, ww, n=length(ww$neighbours), S0=Szero(ww)) #get moran's I
  return(m$I) #returns the moran I for the shuffled TB values
}
```

Get Moran's I values
```{r moran values}
#set seed so we get consistent randomness
set.seed(2)

#sapply works similar to a for loop, but outputs a vector with all the values 1:n
rm <- sapply(1:999, rand.moran) 

#we need the moran of our actual data for the plot
am <- moran(pols$TB, ww, n=length(ww$neighbours), S0=Szero(ww))
```

Figure like 7.9 in OSU
```{r histogram}
#set up the parameters
par(mfrow=c(1,1), mar=c(5, 4, 4, 2) + 0.1)

#get a histogram for the random
hist(rm, main = "Histogram of Montecarlo Simulation of Moran's I", xlab = expression("Moran's"~italic("I")), xlim = c(-0.2, 0.35))

#put a vertical line on the actual moran's I
abline(v=am$I,col= "black", lty=2)

#add the text, vert with srt = 90
text(0.25, 150, "Observed value (p-value 0.001)", col = "black", srt = 90, cex = 0.8) 
```

## 6 DIY Geary C

__Write your own Geary C function, by completing the function below__

`gearyC <- ((n-1)/sum(( "----")^2)) * sum(wm * (" --- ")^2) / (2 * sum(wm))`

Set up for our equation
```{r}
#need weights matrix
wm <- nb2mat(wr, style='B')

#here we get a dataframe that lists the possible combos betwen the TB values
y <- expand.grid(pols$TB, pols$TB)

#rename to make things fit with the equation
colnames(y) <- c("y1", "y2")
```

DIY Geary C equation
```{r diy geary c}
# c equals
# n - 1 / (sum of TB values - Mean)^2
# times
# (sum of wm * (y1 - y2)^2 / 2*the sum of the weights matrix)
gearyC <- ((length(ww$neighbours)-1)/sum((pols$TB - mean(pols$TB))^2)) * sum(wm * (y$y1 - y$y2)^2) / (2 * sum(wm))
```

geary() | user Geary
:---:|:---:
`r c$C` | `r gearyC`

>Looks like my diy Geary C matches the `geary()` output for our data. 

